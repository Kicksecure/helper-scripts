#!/bin/bash

## Copyright (C) 2025 - 2025 ENCRYPTED SUPPORT LLC <adrelanos@whonix.org>
## See the file COPYING for copying conditions.

br_add() {
   local in out

   if (( $# > 1 )); then
      printf '%s\n' "br_add: too many arguments" >&2
      return 1
   fi

   if (( $# == 1 )); then
      in="$1"
   else
      in="$(cat)"
   fi

   ## Replace each newline with "<br />\n"
   out="${in//$'\n'/'<br />'$'\n'}"
   printf '%s\n' "$out"
}

br_add_to_file() {
   local file_name="$1"

   test -f "${file_name}"
   safe-rm -f -- "${file_name}_br"
   touch -- "${file_name}_br"

   local line
   while IFS= read -r line ; do
      printf '%s\n' "$line<br />" | tee -a -- "${file_name}_br" >/dev/null
   done < "${file_name}"
}

read_integer_file() {
  local target_file lower_bound upper_bound file_contents

  target_file="${1:-}"
  lower_bound="${2:-}"
  upper_bound="${3:-}"
  if [ -z "$target_file" ]; then
    printf '%s\n' "$0: ERROR: No target file specified!" >&2
    return 1
  fi
  if [ -n "$lower_bound" ] && ! [[ "$lower_bound" =~ ^[0-9]+$ ]]; then
    printf '%s\n' "$0: ERROR: Non-numeric lower bound specified!" >&2
    return 1
  fi
  if [ -n "$upper_bound" ] && ! [[ "$upper_bound" =~ ^[0-9]+$ ]]; then
    printf '%s\n' "$0: ERROR: Non-numeric upper bound specified!" >&2
    return 1
  fi

  if ! test -f "$target_file" ; then
    printf '%s\n' "$0: ERROR: Target file '$target_file' does not exist!" >&2
    return 1
  fi
  if ! test -r "$target_file" ; then
    printf '%s\n' "$0: ERROR: Target file '$target_file' not readable!" >&2
    return 1
  fi
  if ! file_contents="$(stcat "$target_file")" ; then
    printf '%s\n' "$0: ERROR: Cannot stcat target file '$target_file'!" >&2
    return 1
  fi
  if [ -z "$file_contents" ]; then
    printf '%s\n' "$0: ERROR: Empty target file '$target_file'!" >&2
    return 1
  fi
  if ! [[ "$file_contents" =~ ^[0-9]+$ ]]; then
    printf '%s\n' "$0: ERROR: Non-numeric value in target file '$target_file'!" >&2
    return 1
  fi
  if [ -n "$lower_bound" ] && (( file_contents < lower_bound )); then
    printf '%s\n' "$0: ERROR: Target file's '$target_file' value '$file_contents' is below the lower bound '$lower_bound'!" >&2
    return 1
  fi
  if [ -n "$upper_bound" ] && (( file_contents > upper_bound )); then
    printf '%s\n' "$0: ERROR: Target file's '$target_file' value '$file_contents' is above the upper bound '$upper_bound'!" >&2
    return 1
  fi
  printf '%s\n' "$0: INFO: Target file '$target_file' file_contents: '$file_contents'" >/dev/null
  printf '%s\n' "$file_contents"
}

check_is_alpha_numeric() {
   local varname value

   if [ -z "$1" ]; then
      printf '%s\n' "$0: ERROR: No variable name provided to check_is_alpha_numeric." >&2
      return 1
   fi

   varname="$1"
   value="${!varname}"

   if ! [[ "$value" =~ ^[0-9a-zA-Z_-]+$ ]]; then
      stecho "$0:
\$1 (variable name): '$varname'
\$2 (variable content): '$value'
Invalid character!" >&2
      return 1
   fi
   if [ "$value" = "" ]; then
      stecho "$0:
\$1 (variable name): '$varname'
\$2 (variable content): empty!" >&2
      return 1
   fi

   return 0
}

validate_safe_filename() {
  local varname value reason re

  varname="$1"
  value="${!varname}"

  if [[ -z "$value" ]]; then
    reason="Empty value!"
  elif [[ "$value" == *"/"* || "$value" == *\\* ]]; then
    reason="Path separator not allowed!"
  elif [[ "$value" == "." ]]; then
    reason="Dot path not allowed!"
  elif [[ "$value" == ".." ]]; then
    reason="Double dot path not allowed!"
  elif [[ "$value" == *".."* ]]; then
    reason="Contains '..'!"
  elif [[ "$value" =~ [[:cntrl:]] ]]; then
    reason="Control character not allowed!"
  elif [[ "$value" == -* ]]; then
    reason="Leading '-' not allowed!"
  elif (( ${#value} > 255 )); then
    reason="Too long (>255 chars)!"
  else
    ## Allow: letters/digits (locale-aware), underscore, dash, dot, space,
    ## plus, comma, equals, @, parentheses, braces, square brackets
    re='^[[:alnum:]_.@+=,(){}\[\] -]+$'
    if [[ "$value" =~ $re ]]; then
      return 0
    fi
    reason="Invalid character!"
  fi

  printf 'RAW: <%q>\n' "$value"
  LC_ALL=C od -An -tx1 <<<"$value"

  stecho "$0: ${FUNCNAME[0]}
\$1 (variable name): '$varname'
\$2 (variable content): '$value'
$reason" >&2

  return 1
}

check_is_not_empty_and_only_one_line() {
   local varname value number_of_lines

   if [ -z "$1" ]; then
      printf '%s\n' "$0: ERROR: No variable name provided to check_is_not_empty_and_only_one_line." >&2
      return 1
   fi

   varname="$1"
   value="${!varname}"

   ## Trim leading/trailing spaces while preserving newlines.
   IFS= read -r trimmed_value <<< "$value"

   ## Check if value is empty or only contains spaces/newlines.
   if [[ -z "$trimmed_value" || -z "${value//[[:space:]]/}" ]]; then
      printf '%s\n' "$0: ERROR: Variable '$varname' is empty or contains only whitespace/newlines." >&2
      return 1
   fi

   ## Count the number of lines using mapfile.
   mapfile -t lines <<< "$value"
   number_of_lines="${#lines[@]}"

   if [ "$number_of_lines" -ne 1 ]; then
      printf '%s\n' "$0: ERROR: Variable '$varname' contains more than one line. Content:
'$value'" >&2
      return 1
   fi

   return 0
}

## Converts $1 to a newline-separated, properly escaped list.
## Strips leading and trailing space, crunches multiple
## consecutive spaces into single spaces, then converts spaces to newlines
## and adds spaces and backslashes where necessary.
trim_collapse_split() {
   local input_list="$1"
   local trimmed_list cleaned_list formatted_list

   ## Step 1: Trim leading and trailing spaces.
   trimmed_list="$(printf '%s\n' "$input_list" | sed 's/^\s\+//g; s/\s\+$//g')"

   ## Step 2: Replace multiple spaces with a single space.
   cleaned_list="$(printf '%s\n' "$trimmed_list" | sed 's/\s\+/ /g')"

   ## Step 3: Replace spaces with ' \n' (newline prefixed by space).
   formatted_list="$(printf '%s\n' "$cleaned_list" | sed 's/\s/ \\\n/g')"

   printf '%s\n' "$formatted_list"
}

## success: whole numbers such as 1 2 3 456 etc. (purely numeric only) (isnum)
## fail:
## 5.5
## 5,500
## trailing spaces
## leading spaces
## empty input
## space only
## scientific notation such as 1.23e10
## negative numbers such as -1
is_whole_number() {
   [[ "$1" =~ ^[0-9]+$ ]]
}

## NOTE: Duplicated in package 'uwt' file 'curl.anondist'.
random_alpha_numeric() {
  local n="${1:-43}"
  LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/random | head --bytes="$n" || true
  printf '%s\n' ""
}

run_test() {
   local test_name function_name var_name expected_exit_code var_name value actual_exit_code
   test_name="$1"
   shift
   function_name="$1"
   shift
   expected_exit_code="$1"
   shift
   var_name="$1"
   shift
   value="$@"

   eval "$var_name=\"\$value\""
   printf '%s\n' "$0: Running test: $test_name"

   actual_exit_code=0
   true "Running: $function_name $var_name"
   $function_name "$var_name" || { actual_exit_code=$? ; true; };

   if [ "$actual_exit_code" -eq "$expected_exit_code" ]; then
      printf '%s\n' "$0: Test Passed"
   else
      printf '%s\n' "$0: Test Failed (Expected exit code: '$expected_exit_code', Got: '$actual_exit_code')" >&2
      return 1
   fi
   printf '%s\n' "---------------------------------"
}

tests() {
   local input_string expected_result actual_result

   #run_test test_name function expected_exit_code var_name value

   run_test 1 check_is_alpha_numeric 1 testvar ""
   run_test 2 check_is_alpha_numeric 1 testvar "."
   run_test 3 check_is_alpha_numeric 0 testvar "test"

   run_test a validate_safe_filename 0 testvar "test"
   run_test b validate_safe_filename 1 testvar "."
   run_test c validate_safe_filename 1 testvar ".."

   run_test 4 check_is_not_empty_and_only_one_line 1 a ""
   run_test 5 check_is_not_empty_and_only_one_line 1 a "


   " 1
   run_test 6 check_is_not_empty_and_only_one_line 1 a "   "
   run_test 7 check_is_not_empty_and_only_one_line 0 a "Hello, World!"
   run_test 8 check_is_not_empty_and_only_one_line 1 a "Hello
   World" 1
   run_test 9 check_is_not_empty_and_only_one_line 0 a "  Hello  "


   input_string="test1
test2"
   expected_result="test1<br />
test2"
   actual_result="$(br_add "$input_string")"
   if ! [ "$expected_result" = "$actual_result" ]; then
      error "br_add command failed!"
   fi

   actual_result="$(printf '%s\n' "$input_string" | br_add)"
   if ! [ "$expected_result" = "$actual_result" ]; then
      error "br_add pipe failed!"
   fi

   printf '%s\n' "$0: All Tests Passed"
}

strings_bsh_error_trap() {
  local last_exit_code="$?"
  echo "$0: ERROR: failed: '$BASH_COMMAND'"
  exit 1
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
   set -o errexit
   set -o errtrace
   set -o pipefail
   set -o nounset
   trap strings_bsh_error_trap ERR
   tests
fi

#trim_collapse_split " aaa  bbb ccc ddd "
#flavor_meta_packages_to_install='kicksecure-baremetal-gui-lxqt kicksecure-baremetal-server'
#trim_collapse_split "$flavor_meta_packages_to_install"
